# System_Programming_named_pipes


```
# Εντολή Μεταγλώτισσης:
Για το Monitor.c
gcc -o Monitor Monitor.c citizen.c list.c functions.c skipList.c
Για το travelMonitor.c
gcc -o travelMonitor travelMonitor.c functions.c list.c citizen.c skipList.c 

# Εντολή Εκτέλεσης:
./travelMonitor -m <numMonitor> -b <bufferSize> -s <bloomSize> -i input_dir

```

### TravelMonitor.c 

Ξεκινώντας την υλοποίηση του travelMonitor ανοίγουμε το directory input_dir και αποθηκεύουμε τον αριθμό των χωρών και τα ονόματα των χωρών σε μια λίστα για να τα διαχειριστούμε αργότερα.
Επίσης δημιουργούμε ένα πίνακα από struct monitor οπου περιέχει τις πληροφορίες για το κάθε monitor. Οι πληροφορίες αυτές είναι το pid του παιδιού  τα paths για τα named pipes που θα φτιάξουμε στην συνέχεια, Οι χώρες που θα διαχειρίζεται και ο αριθμός των χωρών.

Στην συνέχεια δημιουργούμε τα paths που θα έχει κάθε child-parant για την επικοινωνία μέσω named pipes. 

Τέλος δημιουργούμε τα named pipes (ενα για να γράφει ο πατέρας και να διαβάζει και ένα αντίστροφο) κάνουμε fork τα παιδία και καλούμε την exec με ορίσματα τα δύο named pipes paths που ανέφερα παραπάνω.

Τα πρώτα μηνύματα που θα στείλει ο πατέρας προς τα παιδιά είναι το bloom size , το buffer size και τον αριθμό των χωρών που θα έχει κάθε παιδί (τελικά δεν χρειάστηκε)  έτσι ώστε να ενημερώσουν τις μεταβλητές τους. Στην συνέχεια ο πατέρας ξανανοίγει το input_dir και στέλνει με round-robin τις χώρες που θα αναλάβει κάθε παιδί. 

Για την αποστολή των μηνυμάτων στην περίπτωση που το μήνυμα είναι μεγαλύτερο απο το buffer size έχω φτιάξει δύο συναρτήσεις την writefifo και readFifo.

writefifo: Παίρνει σαν ορίσματα τον file descriptor το μήνυμα και το buffer size. Υπολογίζει το το μέγεθος του μηνύματος και το σπάει σε κομμάτια (chunks) μεγέθους ίσο με buffer size. Στην συνέχεια υπολογίζει και τα bytes που υπολείπονται και έχουν μέγεθος μικρότερο από buffer size.
Στην συνέχεια και με τους κατάλληλους ελέγχους με μια επανάληψη (chunks+1) στέλνουμε το μήνυμα.

readFifo: Και την συγκεκριμένη συνάρτηση την χρησιμοποιούμε για να διαβάσουμε ένα μήνυμα όπου είναι μεγαλύτερο από buffer size.
Η λογική της είναι πολύ απλή. Σε μία επανάληψη καλούμε την read μεχρι η τιμή που θα επιστρέψει η read να είναι 0 (δηλαδή δεν έχουμε άλλα bytes για διάβασμα) και με την χρήση της realloc ενώνουμε όλα τα κομμάτια του μηνύματος. Τέλος προσθέτουμε το “\0” για να γνωρίζουμε που τερματίζει το string.
<br />
### Monitor.c
<br />
Ξεκινώντας το monitor διαβάζει αρχικά όπως προανέφερα το bloom size και το buffer size και των αριθμό των χωρών που θα έχει κάθε παιδί. Στην συνέχεια με την χρήση της epoll ξεκινάμε να διαβάζουμε τις χώρες που του στέλνει το parent process (Στην αρχή προσπάθησα να χρησιμοποιήσω την select αλλα λογικά κάποιο λάθος έκανα και δεν δούλευε σωστά). Την epoll την χρησιμοποιούμε για να περιμένει το παιδί μέχρι να υπάρξουν δεδομένα προς διάβασμα έτσι ώστε να μην μπλοκάρετε η αποστολή δεδομένων. 

Στην συνέχεια αποθηκεύει τις χώρες τις οποίες διάβασε. Αργότερα ανοίγει τους εκάστοτε φακέλους των χωρών, και όπως και στην προηγούμενη εργασία αποθηκεύω τις εγγραφές στο hashTable όπου έχουμε δημιουργήσει, δημιουργούμε τα bloom filters και τις skipList και καταχωρούμε τα δεδομένα. 

Signals: Για τα signals χρησιμοποιώ την δομή sigaction έτσι ώστε να μπορέσω να κάνω handling το εκάστοτε signal. Έχω δημιουργήσει global flags έτσι ώστε όταν το πρόγραμμα λάβει κάποιο σήμα να αλλάζει την τιμή του flag και να εκτελεί την εκάστοτε ενέργεια.


Ξεκινώντας η προσομοίωση του travelMonitor περιμένει το input από από τον χρήστη. Για να αναφερθώ στα monitors και να ανοίξουν τo pipe είτε μονωμένα είτε όλα μαζί χρησιμοποιώ signals. 
<br />
./travelRequest.
Στην συγκεκριμένη λειτουργία αρχικά ψάχνω να βρω πιο monitor έχει την χώρα countryFrom. Μόλις την βρω στέλνω ενα signal στο αντίστοιχο monitor για να ανοιξει την σωλήνωση και να διαβάσει τα δεδομένα. Χρησιμοποιώ τις skipList που έχω φτιάξει από την προηγούμενη εργασία. Αν ο πολίτης είναι εμβολιασμένος μέσα στο 6μηνο απαντάει YES στο parent process μέσω του named pipe. Αν ο πολίτης δεν είναι εμβολιασμένος απαντάει ΝΟ. Αν έχει παρέλθει το 6μηνο από τον εμβολιασμό τότε απαντάει NOM. Ανάλογα την μήνυμα που θα λάβει ο parent εκτυπώνει το εκάστοτε μήνυμα. Τέλος έχω φτιάξει μία λίστα Requests όπου αποθηκεύω όλα τα request. Συνεπώς αν λάβω μία αρνητική απάντηση, στην λίστα με τα request θα προσθέσω ότι για την countryTo έχουμε ένα reject request για την εκάστοτε ημερομηνία ταξιδιού.

<br />
/travelStats
Για την συγκεκριμένη λειτουργία χρησιμοποιώ την λίστα με τα requests που ανέφερα νωρίτερα. Ανάλογα με την αν έχει δοθεί όρισμα country κοιτάζω μονωμένα τα request για αυτην την χώρα αλλιώς κοιτάζω για όλες τις χώρες, και εκτυπώνω τα αποτελέσματα.
<br />
/searchVaccinationStatus 
Για την συγκεκριμένη λειτουργία στέλνω ένα signal SIGUSR2 σε όλα τα monitor για να ψάξουν για τον πολίτη με το αντίστοιχο id, Στην συνέχεια το monitor που διαχειρίζεται τον πολίτη στέλνει τα δεδομένα του και για ποιες ιώσεις είναι εμβολιασμένος και εκτυπώνονται.
<br />
/addVaccinationRecords
Στην συγκεκριμένη λειτουργία ανάλογα με το όρισμα country που μας έχει δωθεί στον αντίστοιχο υποκατάλογο την χώρας ένα καινούργιο αρχείο και προσθέτω κάποιες εγγραφές, Οι οποίες γίνονται random. Στην συνέχεια βρίσκω ποιο monitor διαχειρίζεται αυτην την χώρα και του στέλνω ένα signal έτσι ώστε να ανοίξει και να ανανεώσει τα δεδομένα του. Το monitor ξεκινάει ξανά την ανάγνωση όλων των υποκαταλόγων των εκάστοτε χωρών. αλλα  κάνει skip αυτούς που ήδη έχει διαβάσει. Αυτην την λειτουργία του skip την υλοποιώ καθώς κατά την αρχική ανάγνωση των αρχείων αποθηκεύω τα ονόμα. Οπότε αν ένα όνομα αρχείου έχει ήδη διαβαστεί το παραλείπω. Τέλος ανανεώνει όλες τις δομές και είναι έτοιμο να δεχθεί νέα queries με τις ανανεωμένες δομές. 

SIGQUIT η SIGINT αν δεχθεί ο parent ή τα childs ένα από τα αντίστοιχα signals τότε δημιουργεί τα log_files όπως περιγράφονται στην εκφώνηση.
<br />
./exit 
Ο parent στέλνει το SIGKILL signal στα παιδιά για να τερματίσουν( το οποίο δεν μπορεί να γίνει handle και ύστερα τερματίζει ελευθερώνοντας την μνημη.
